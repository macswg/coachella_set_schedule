{% extends "base.html" %}

{% block title %}{{ stage_name }} - Festival Schedule{% endblock %}

{% block content %}
<div class="container" x-data="scheduleApp()" x-init="init()">
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <h1>{{ stage_name }}</h1>
        </div>
        <div class="header-center">
            <div class="current-time" x-text="currentTime"></div>
            {% if not view_only %}
            <div class="time-override">
                <input type="time"
                       x-model="timeOverride"
                       @change="applyTimeOverride()"
                       step="1"
                       placeholder="HH:MM:SS">
                <button x-show="timeOverride" @click="clearTimeOverride()" class="btn-clear-time">Live</button>
            </div>
            {% endif %}
        </div>
        <div class="header-right">
            <div class="brightness-display">
                <span class="brightness-label">Brightness:</span>
                <span class="brightness-value" x-text="brightness + ' nits'"></span>
            </div>
            <div class="slip-display" :class="{ 'slip-warning': slip > 0, 'slip-ahead': slip < 0 }">
                <span class="slip-label">Slip:</span>
                <span class="slip-value" x-text="formatSlip(slip)"></span>
            </div>
        </div>
    </header>

    <!-- Now Playing / Up Next Section (hidden on Chrome iOS due to scroll bug) -->
    <section class="now-playing-section" id="now-playing-section"></section>

    <!-- Schedule List -->
    <main class="schedule" hx-ext="ws" ws-connect="/ws?mode={% if view_only %}view{% else %}edit{% endif %}">
        <div class="schedule-header">
            {% if sheet_tab %}
            <span class="sheet-tab-label">Sheet: {{ sheet_tab }}</span>
            {% endif %}
            <button class="btn-toggle-completed" @click="hideCompleted = !hideCompleted">
                <span x-text="hideCompleted ? 'Show Completed' : 'Hide Completed'"></span>
            </button>
        </div>
        <div class="schedule-list" id="schedule-list" :class="{ 'hide-completed': hideCompleted }">
            {% for act in acts %}
                {% include "components/act_row.html" %}
            {% endfor %}
        </div>
    </main>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" x-show="confirmUrl" x-cloak @click.self="confirmUrl = ''" @keydown.escape.window="confirmUrl = ''">
        <div class="modal-box">
            <p class="modal-message" x-text="confirmMessage"></p>
            <div class="modal-actions">
                <button class="btn btn-modal-cancel" @click="confirmUrl = ''">Cancel</button>
                <button class="btn btn-modal-confirm" @click="fetch(confirmUrl, {method: 'POST'}); confirmUrl = ''">Clear</button>
            </div>
        </div>
    </div>
</div>

<script>
function scheduleApp() {
    return {
        currentTime: '',
        slip: {{ slip }},
        brightness: 0,
        timeOverride: '',
        frozenTime: null,
        confirmMessage: '',
        confirmUrl: '',
        hideCompleted: true,

        init() {
            this.updateTime();
            setInterval(() => this.updateTime(), 1000);
            this.fetchBrightness();
            this.setupBrightnessListener();
            // Make now-playing section sticky on Chrome iOS to avoid scroll bug
            if (/CriOS/.test(navigator.userAgent)) {
                const section = document.getElementById('now-playing-section');
                if (section) section.classList.add('np-sticky');
            }
        },

        async fetchBrightness() {
            try {
                const response = await fetch('/api/brightness');
                const data = await response.json();
                this.brightness = data.value;
            } catch (e) {
                console.error('Failed to fetch brightness:', e);
            }
        },

        setupBrightnessListener() {
            const self = this;
            document.body.addEventListener('htmx:wsBeforeMessage', function(event) {
                try {
                    const data = JSON.parse(event.detail.message);
                    if (data.type === 'brightness') {
                        self.brightness = data.value;
                        event.preventDefault();
                    }
                } catch (e) {
                    // Not JSON, let HTMX handle it as HTML
                }
            });
        },

        updateTime() {
            if (this.frozenTime) {
                this.currentTime = this.frozenTime;
            } else {
                const now = new Date();
                this.currentTime = now.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            }
            this.calculateSlip();
            this.checkActAlerts();
            this.updateNowPlaying();
        },

        timeToSeconds(timeStr) {
            if (!timeStr) return null;
            const parts = timeStr.split(':');
            const hours = parseInt(parts[0]);
            const mins = parseInt(parts[1]);
            const secs = parts[2] ? parseInt(parts[2]) : 0;
            return hours * 3600 + mins * 60 + secs;
        },

        calculateSlip() {
            const currentSecs = this.timeToSeconds(this.currentTime);
            let slip = 0;

            document.querySelectorAll('.act-row').forEach(row => {
                const scheduledStart = this.timeToSeconds(row.dataset.scheduledStart);
                const scheduledEnd = this.timeToSeconds(row.dataset.scheduledEnd);
                const actualStart = this.timeToSeconds(row.dataset.actualStart);
                const actualEnd = this.timeToSeconds(row.dataset.actualEnd);

                if (actualEnd !== null) {
                    // Completed act: slip is how early/late it ended
                    slip = actualEnd - scheduledEnd;
                } else if (actualStart !== null) {
                    if (currentSecs > scheduledEnd) {
                        // In-progress act past scheduled end: show actual overtime
                        slip = currentSecs - scheduledEnd;
                    } else {
                        // In-progress within scheduled time: show start variance
                        slip = actualStart - scheduledStart;
                    }
                }
            });

            this.slip = slip;
        },

        checkActAlerts() {
            const currentSecs = this.timeToSeconds(this.currentTime);
            const fiveMin = 300;

            document.querySelectorAll('.act-row').forEach(row => {
                const startSecs = this.timeToSeconds(row.dataset.scheduledStart);
                const endSecs = this.timeToSeconds(row.dataset.scheduledEnd);
                const hasStart = row.dataset.actualStart !== '';
                const hasEnd = row.dataset.actualEnd !== '';

                row.classList.remove('flash-warning', 'flash-danger', 'act-live', 'act-live-ending');

                if (!hasStart && currentSecs >= startSecs - fiveMin && currentSecs < endSecs) {
                    row.classList.add('flash-warning');
                } else if (hasStart && !hasEnd) {
                    if (currentSecs >= endSecs) {
                        row.classList.add('flash-danger');
                    } else if (currentSecs >= endSecs - fiveMin) {
                        row.classList.add('act-live-ending');
                    } else {
                        row.classList.add('act-live');
                    }
                }
            });
        },

        updateNowPlaying() {
            const section = document.getElementById('now-playing-section');
            if (!section) return;

            const currentSeconds = this.timeToSeconds(this.currentTime);
            const actRows = document.querySelectorAll('.act-row');

            let nowPlaying = null;
            let upNext = null;
            let countdown = '';
            let isOvertime = false;
            let isLateStart = false;

            let shouldBePlayingNow = null;
            let nextUpcoming = null;

            for (const row of actRows) {
                const actName = row.querySelector('.act-name').textContent;
                const scheduledStart = row.dataset.scheduledStart;
                const scheduledEnd = row.dataset.scheduledEnd;
                const hasActualStart = row.dataset.actualStart !== '';
                const hasActualEnd = row.dataset.actualEnd !== '';

                const startSeconds = this.timeToSeconds(scheduledStart);
                const endSeconds = this.timeToSeconds(scheduledEnd);

                if (hasActualStart && !hasActualEnd) {
                    nowPlaying = actName;
                    const remaining = endSeconds - currentSeconds;
                    countdown = this.formatCountdown(remaining);
                    isOvertime = remaining < 0;
                    break;
                }

                if (hasActualEnd) continue;

                if (!hasActualStart && currentSeconds >= startSeconds && currentSeconds < endSeconds) {
                    shouldBePlayingNow = { name: actName, startSeconds, endSeconds };
                }

                if (!hasActualStart && currentSeconds < startSeconds && !nextUpcoming) {
                    nextUpcoming = { name: actName, startSeconds };
                }
            }

            if (!nowPlaying && shouldBePlayingNow) {
                upNext = shouldBePlayingNow.name;
                const lateBy = currentSeconds - shouldBePlayingNow.startSeconds;
                countdown = this.formatCountdown(-lateBy);
                isLateStart = true;
            } else if (!nowPlaying && nextUpcoming) {
                upNext = nextUpcoming.name;
                countdown = this.formatCountdown(nextUpcoming.startSeconds - currentSeconds);
                isLateStart = false;
            }

            // Update DOM
            if (nowPlaying) {
                section.innerHTML = `
                    <div class="now-playing ${isOvertime ? 'is-overtime' : ''}">
                        <span class="np-label">Now Playing</span>
                        <span class="np-artist">${nowPlaying}</span>
                        <div class="np-countdown-wrap">
                            <span class="np-countdown ${isOvertime ? 'overtime' : ''}">${countdown}</span>
                            <span class="np-suffix">${isOvertime ? 'over' : 'remaining'}</span>
                        </div>
                    </div>`;
            } else if (upNext) {
                section.innerHTML = `
                    <div class="up-next ${isLateStart ? 'is-late-start' : ''}">
                        <span class="np-label">${isLateStart ? 'Should Be On' : 'Up Next'}</span>
                        <span class="np-artist">${upNext}</span>
                        <div class="np-countdown-wrap">
                            <span class="np-countdown ${isLateStart ? 'late-start' : ''}">${countdown}</span>
                            <span class="np-suffix">${isLateStart ? 'late' : 'until start'}</span>
                        </div>
                    </div>`;
            } else {
                section.innerHTML = '';
            }
        },

        formatCountdown(seconds) {
            const isOver = seconds < 0;
            const absSeconds = Math.abs(seconds);
            const hrs = Math.floor(absSeconds / 3600);
            const mins = Math.floor((absSeconds % 3600) / 60);
            const secs = absSeconds % 60;

            let time;
            if (hrs > 0) {
                time = `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                time = `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            return isOver ? `+${time}` : time;
        },

        applyTimeOverride() {
            if (this.timeOverride) {
                this.frozenTime = this.timeOverride;
                this.currentTime = this.frozenTime;
                this.checkActAlerts();
            }
        },

        clearTimeOverride() {
            this.timeOverride = '';
            this.frozenTime = null;
            this.updateTime();
        },

        formatSlip(seconds) {
            if (seconds === 0) return 'On Time';
            const abs = Math.abs(seconds);
            const mins = Math.floor(abs / 60);
            const secs = abs % 60;
            const suffix = seconds > 0 ? ' late' : ' early';
            if (mins > 0) {
                return `${mins}m ${secs}s${suffix}`;
            }
            return `${secs}s${suffix}`;
        },

        confirm(message, url) {
            this.confirmMessage = message;
            this.confirmUrl = url;
        }
    }
}
</script>
{% endblock %}

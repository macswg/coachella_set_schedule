{% extends "base.html" %}

{% block title %}{{ stage_name }} - Festival Schedule{% endblock %}

{% block content %}
<div class="container" x-data="scheduleApp()" x-init="init()">
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <h1>{{ stage_name }}</h1>
        </div>
        <div class="header-center">
            <div class="current-time" x-text="currentTime"></div>
            {% if not view_only %}
            <div class="time-override">
                <input type="time"
                       x-model="timeOverride"
                       @change="applyTimeOverride()"
                       step="1"
                       placeholder="HH:MM:SS">
                <button x-show="timeOverride" @click="clearTimeOverride()" class="btn-clear-time">Live</button>
            </div>
            {% endif %}
        </div>
        <div class="header-right">
            <div class="brightness-display">
                <span class="brightness-label">Brightness:</span>
                <span class="brightness-value" x-text="brightness + ' nits'"></span>
            </div>
            <div class="slip-display" :class="{ 'slip-warning': slip > 0, 'slip-ahead': slip < 0 }">
                <span class="slip-label">Slip:</span>
                <span class="slip-value" x-text="formatSlip(slip)"></span>
            </div>
        </div>
    </header>

    <!-- Now Playing / Up Next Section (hidden on Chrome iOS due to scroll bug) -->
    <section class="now-playing-section" id="now-playing-section"></section>

    <!-- Schedule List -->
    <main class="schedule" hx-ext="ws" ws-connect="/ws?mode={% if view_only %}view{% else %}edit{% endif %}">
        <div class="schedule-header">
            {% if sheet_tab %}
            <span class="sheet-tab-label">Sheet: {{ sheet_tab }}</span>
            {% endif %}
	    {% if not view_only %}
            <button class="btn-reset-all" @click="confirmMessage = 'Reset all actual times? This will clear all recorded start and end times.'; confirmUrl = '/api/reset'">
                Reset All Times
            </button>
            {% endif %}
	    <button class="btn-toggle-completed" @click="hideCompleted = !hideCompleted">
                <span x-text="hideCompleted ? 'Show Completed' : 'Hide Completed'"></span>
            </button>
        </div>
        <div class="schedule-list" id="schedule-list" :class="{ 'hide-completed': hideCompleted }">
            {% for act in acts %}
                {% include "components/act_row.html" %}
            {% endfor %}
        </div>
    </main>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" x-show="confirmUrl" x-cloak @click.self="confirmUrl = ''" @keydown.escape.window="confirmUrl = ''">
        <div class="modal-box">
            <p class="modal-message" x-text="confirmMessage"></p>
            <div class="modal-actions">
                <button class="btn btn-modal-cancel" @click="confirmUrl = ''">Cancel</button>
                <button class="btn btn-modal-confirm" @click="fetch(confirmUrl, {method: 'POST'}); confirmUrl = ''">Clear</button>
            </div>
        </div>
    </div>
</div>

<script>
function scheduleApp() {
    return {
        currentTime: '',
        slip: {{ slip }},
        brightness: 0,
        timeOverride: '',
        frozenTime: null,
        confirmMessage: '',
        confirmUrl: '',
        hideCompleted: true,

        init() {
            this.updateTime();
            setInterval(() => this.updateTime(), 1000);
            this.fetchBrightness();
            this.setupBrightnessListener();
            document.body.addEventListener('htmx:wsAfterMessage', () => this.updateTime());
            // Make now-playing section sticky on Chrome iOS to avoid scroll bug
            if (/CriOS/.test(navigator.userAgent)) {
                const section = document.getElementById('now-playing-section');
                if (section) section.classList.add('np-sticky');
            }
        },

        async fetchBrightness() {
            try {
                const response = await fetch('/api/brightness');
                const data = await response.json();
                this.brightness = data.value;
            } catch (e) {
                console.error('Failed to fetch brightness:', e);
            }
        },

        setupBrightnessListener() {
            const self = this;
            document.body.addEventListener('htmx:wsBeforeMessage', function(event) {
                try {
                    const data = JSON.parse(event.detail.message);
                    if (data.type === 'brightness') {
                        self.brightness = data.value;
                        event.preventDefault();
                    }
                } catch (e) {
                    // Not JSON, let HTMX handle it as HTML
                }
            });
        },

        updateTime() {
            if (this.frozenTime) {
                this.currentTime = this.frozenTime;
            } else {
                const now = new Date();
                this.currentTime = now.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            }

            const currentSecs = this.timeToSeconds(this.currentTime);
            const acts = [];
            document.querySelectorAll('.act-row').forEach(row => {
                acts.push({
                    row,
                    scheduledStart: this.timeToSeconds(row.dataset.scheduledStart),
                    scheduledEnd: this.timeToSeconds(row.dataset.scheduledEnd),
                    actualStart: this.timeToSeconds(row.dataset.actualStart),
                    actualEnd: this.timeToSeconds(row.dataset.actualEnd),
                    hasActualStart: row.dataset.actualStart !== '',
                    hasActualEnd: row.dataset.actualEnd !== '',
                });
            });

            this.calculateSlip(currentSecs, acts);
            this.checkActAlerts(currentSecs, acts);
            this.updateNowPlaying(currentSecs, acts);
            this.updateCountdowns(currentSecs, acts);
        },

        timeToSeconds(timeStr) {
            if (!timeStr) return null;
            const parts = timeStr.split(':');
            const hours = parseInt(parts[0]);
            const mins = parseInt(parts[1]);
            const secs = parts[2] ? parseInt(parts[2]) : 0;
            return hours * 3600 + mins * 60 + secs;
        },

        calculateSlip(currentSecs, acts) {
            let slip = 0;

            for (const act of acts) {
                if (act.actualEnd !== null) {
                    // Completed act: slip is how early/late it ended
                    slip = act.actualEnd - act.scheduledEnd;
                } else if (act.actualStart !== null) {
                    if (currentSecs > act.scheduledEnd) {
                        // In-progress act past scheduled end: show actual overtime
                        slip = currentSecs - act.scheduledEnd;
                    } else {
                        // In-progress within scheduled time: show start variance
                        slip = act.actualStart - act.scheduledStart;
                    }
                }
            }

            this.slip = slip;
        },

        checkActAlerts(currentSecs, acts) {
            const fiveMin = 300;

            for (const act of acts) {
                act.row.classList.remove('flash-warning', 'flash-danger', 'act-live', 'act-live-ending');

                if (!act.hasActualStart && currentSecs >= act.scheduledStart - fiveMin && currentSecs < act.scheduledEnd) {
                    act.row.classList.add('flash-warning');
                } else if (act.hasActualStart && !act.hasActualEnd) {
                    if (currentSecs >= act.scheduledEnd) {
                        act.row.classList.add('flash-danger');
                    } else if (currentSecs >= act.scheduledEnd - fiveMin) {
                        act.row.classList.add('act-live-ending');
                    } else {
                        act.row.classList.add('act-live');
                    }
                }
            }
        },

        updateNowPlaying(currentSecs, acts) {
            const section = document.getElementById('now-playing-section');
            if (!section) return;

            let nowPlaying = null;
            let upNext = null;
            let countdown = '';
            let isOvertime = false;
            let isLateStart = false;

            let shouldBePlayingNow = null;
            let nextUpcoming = null;

            for (const act of acts) {
                const actName = act.row.querySelector('.act-name').textContent;

                if (act.hasActualStart && !act.hasActualEnd) {
                    nowPlaying = actName;
                    const remaining = act.scheduledEnd - currentSecs;
                    countdown = this.formatCountdown(remaining);
                    isOvertime = remaining < 0;
                    break;
                }

                if (act.hasActualEnd) continue;

                if (!act.hasActualStart && currentSecs >= act.scheduledStart && currentSecs < act.scheduledEnd) {
                    shouldBePlayingNow = { name: actName, startSecs: act.scheduledStart, endSecs: act.scheduledEnd };
                }

                if (!act.hasActualStart && currentSecs < act.scheduledStart && !nextUpcoming) {
                    nextUpcoming = { name: actName, startSecs: act.scheduledStart };
                }
            }

            if (!nowPlaying && shouldBePlayingNow) {
                upNext = shouldBePlayingNow.name;
                const lateBy = currentSecs - shouldBePlayingNow.startSecs;
                countdown = this.formatCountdown(-lateBy);
                isLateStart = true;
            } else if (!nowPlaying && nextUpcoming) {
                upNext = nextUpcoming.name;
                countdown = this.formatCountdown(nextUpcoming.startSecs - currentSecs);
                isLateStart = false;
            }

            // Update DOM
            if (nowPlaying) {
                section.innerHTML = `
                    <div class="now-playing ${isOvertime ? 'is-overtime' : ''}">
                        <span class="np-label">Now Playing</span>
                        <span class="np-artist">${nowPlaying}</span>
                        <div class="np-countdown-wrap">
                            <span class="np-countdown ${isOvertime ? 'overtime' : ''}">${countdown}</span>
                            <span class="np-suffix">${isOvertime ? 'over' : 'remaining'}</span>
                        </div>
                    </div>`;
            } else if (upNext) {
                section.innerHTML = `
                    <div class="up-next ${isLateStart ? 'is-late-start' : ''}">
                        <span class="np-label">${isLateStart ? 'Should Be On' : 'Up Next'}</span>
                        <span class="np-artist">${upNext}</span>
                        <div class="np-countdown-wrap">
                            <span class="np-countdown ${isLateStart ? 'late-start' : ''}">${countdown}</span>
                            <span class="np-suffix">${isLateStart ? 'late' : 'until start'}</span>
                        </div>
                    </div>`;
            } else {
                section.innerHTML = '';
            }
        },

        updateCountdowns(currentSecs, acts) {
            for (const act of acts) {
                const el = act.row.querySelector('.act-countdown');
                if (!el) continue;

                if (act.hasActualStart || act.hasActualEnd || currentSecs >= act.scheduledStart) {
                    el.textContent = '';
                } else {
                    const remaining = act.scheduledStart - currentSecs;
                    el.textContent = '[Starts in ' + this.formatCountdown(remaining) + ']';
                }
            }
        },

        formatCountdown(seconds) {
            const isOver = seconds < 0;
            const absSeconds = Math.abs(seconds);
            const hrs = Math.floor(absSeconds / 3600);
            const mins = Math.floor((absSeconds % 3600) / 60);
            const secs = absSeconds % 60;

            let time;
            if (hrs > 0) {
                time = `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                time = `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            return isOver ? `+${time}` : time;
        },

        applyTimeOverride() {
            if (this.timeOverride) {
                this.frozenTime = this.timeOverride;
                this.currentTime = this.frozenTime;
                this.checkActAlerts();
            }
        },

        clearTimeOverride() {
            this.timeOverride = '';
            this.frozenTime = null;
            this.updateTime();
        },

        formatSlip(seconds) {
            if (seconds === 0) return 'On Time';
            const abs = Math.abs(seconds);
            const mins = Math.floor(abs / 60);
            const secs = abs % 60;
            const suffix = seconds > 0 ? ' late' : ' early';
            if (mins > 0) {
                return `${mins}m ${secs}s${suffix}`;
            }
            return `${secs}s${suffix}`;
        },

        confirm(message, url) {
            this.confirmMessage = message;
            this.confirmUrl = url;
        }
    }
}
</script>
{% endblock %}
